import { ChatCompletionMessage } from '@shared/types/api/routes/shared/messages';
import { z } from 'zod';

/**
 * Log probability information for a token.
 */
export const ChatCompletionTokenLogprob = z.object({
  /** The token. */
  token: z.string(),
  /** The log probability of this token, if it is within the top 20 most likely tokens. */
  logprob: z.number(),
  /** A list of integers representing the UTF-8 bytes representation of the token. */
  bytes: z.array(z.number()).optional(),
  /** List of the most likely tokens and their log probabilities at this token position. */
  top_logprobs: z
    .array(
      z.object({
        /** The token. */
        token: z.string(),
        /** The log probability of this token. */
        logprob: z.number(),
        /** A list of integers representing the UTF-8 bytes representation of the token. */
        bytes: z.array(z.number()).optional(),
      }),
    )
    .optional(),
});

export type ChatCompletionTokenLogprob = z.infer<
  typeof ChatCompletionTokenLogprob
>;

/**
 * Log probability information for the choice.
 */
export const ChatCompletionChoiceLogprobs = z.object({
  /** A list of message content tokens with log probability information. */
  content: z.array(ChatCompletionTokenLogprob).nullable(),
  /** A list of message refusal tokens with log probability information. */
  refusal: z.array(ChatCompletionTokenLogprob).nullable().optional(),
});

export type ChatCompletionChoiceLogprobs = z.infer<
  typeof ChatCompletionChoiceLogprobs
>;

export enum ChatCompletionFinishReason {
  STOP = 'stop',
  LENGTH = 'length',
  TOOL_CALLS = 'tool_calls',
  CONTENT_FILTER = 'content_filter',
  FUNCTION_CALL = 'function_call',
}

/**
 * A chat completion choice.
 */
export const ChatCompletionChoice = z.object({
  /** The reason the model stopped generating tokens. */
  finish_reason: z.enum(ChatCompletionFinishReason).nullable(),
  /** The index of the choice in the list of choices. */
  index: z.number(),
  /** A chat completion message generated by the model. */
  message: ChatCompletionMessage,
  /** Log probability information for the choice. */
  logprobs: ChatCompletionChoiceLogprobs.nullable().optional(),
});

export type ChatCompletionChoice = z.infer<typeof ChatCompletionChoice>;

/**
 * Usage statistics for the completion request.
 */
export const ChatCompletionUsage = z.object({
  /** Number of tokens in the generated completion. */
  completion_tokens: z.number().min(0, 'Token count cannot be negative'),
  /** Number of tokens in the prompt. */
  prompt_tokens: z.number().min(0, 'Token count cannot be negative'),
  /** Total number of tokens used in the request (prompt + completion). */
  total_tokens: z.number().min(0, 'Token count cannot be negative'),
  /** Breakdown of tokens used in a completion. */
  completion_tokens_details: z
    .object({
      /** Audio tokens generated by the model. */
      audio_tokens: z.number().optional(),
      /** Reasoning tokens generated by the model. */
      reasoning_tokens: z.number().optional(),
    })
    .optional(),
  /** Breakdown of tokens used in the prompt. */
  prompt_tokens_details: z
    .object({
      /** Audio tokens in the prompt. */
      audio_tokens: z.number().optional(),
      /** Cached tokens in the prompt. */
      cached_tokens: z.number().optional(),
    })
    .optional(),
});

export type ChatCompletionUsage = z.infer<typeof ChatCompletionUsage>;

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export const ChatCompletionResponseBody = z.object({
  /** A unique identifier for the chat completion. */
  id: z.string(),
  /** A list of chat completion choices. */
  choices: z.array(ChatCompletionChoice),
  /** The Unix timestamp (in seconds) of when the chat completion was created. */
  created: z.number().transform((v) => {
    // Standardize the created timestamp to be in seconds
    if (v.toString().length > 10) {
      return Math.floor(v / 1000);
    }
    return v;
  }),
  /** The model used for the chat completion. */
  model: z.string(),
  /** The object type, which is always `chat.completion`. */
  object: z.literal('chat.completion'),
  /** This fingerprint represents the backend configuration that the model runs with. */
  system_fingerprint: z.string().optional().nullable(),
  /** Usage statistics for the completion request. */
  usage: ChatCompletionUsage.optional(),
  /** The service tier used for processing the request. */
  service_tier: z
    .union([z.literal('scale'), z.literal('default')])
    .nullable()
    .optional(),
});

export type ChatCompletionResponseBody = z.infer<
  typeof ChatCompletionResponseBody
>;

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export const ChatCompletionChunk = z.object({
  /** A unique identifier for the chat completion. Each chunk has the same ID. */
  id: z.string(),
  /** A list of chat completion choices. Can contain more than one elements if n is greater than 1. */
  choices: z.array(
    z.object({
      /** A chat completion delta generated by streamed model responses. */
      delta: z.object({
        /** The contents of the chunk message. */
        content: z.string().nullable().optional(),
        /** The refusal message generated by the model. */
        refusal: z.string().nullable().optional(),
        /** The role of the author of this message. */
        role: z
          .union([
            z.literal('system'),
            z.literal('user'),
            z.literal('assistant'),
            z.literal('tool'),
          ])
          .optional(),
        /** The tool calls generated by the model, such as function calls. */
        tool_calls: z
          .array(
            z.object({
              index: z.number(),
              /** The ID of the tool call. */
              id: z.string().optional(),
              /** The type of the tool. Currently, only `function` is supported. */
              type: z.literal('function').optional(),
              /** The function that the model called. */
              function: z
                .object({
                  /** The arguments to call the function with, as generated by the model in JSON format. */
                  arguments: z.string().optional(),
                  /** The name of the function to call. */
                  name: z.string().optional(),
                })
                .optional(),
            }),
          )
          .optional(),
        /** @deprecated Deprecated and replaced by `tool_calls`. */
        function_call: z
          .object({
            /** The arguments to call the function with, as generated by the model in JSON format. */
            arguments: z.string().optional(),
            /** The name of the function to call. */
            name: z.string().optional(),
          })
          .optional(),
      }),
      /** Log probability information for the choice. */
      logprobs: ChatCompletionChoiceLogprobs.nullable().optional(),
      /** The reason the model stopped generating tokens. */
      finish_reason: z
        .union([
          z.literal('stop'),
          z.literal('length'),
          z.literal('tool_calls'),
          z.literal('content_filter'),
          z.literal('function_call'),
        ])
        .nullable()
        .optional(),
      /** The index of the choice in the list of choices. */
      index: z.number(),
    }),
  ),
  /** The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp. */
  created: z.number(),
  /** The model to generate the completion. */
  model: z.string(),
  /** The object type, which is always `chat.completion.chunk`. */
  object: z.literal('chat.completion.chunk'),
  /** The service tier used for processing the request. */
  service_tier: z
    .union([z.literal('scale'), z.literal('default')])
    .nullable()
    .optional(),
  /** This fingerprint represents the backend configuration that the model runs with. */
  system_fingerprint: z.string().optional().nullable(),
  /** An optional field that will only be present when you set `stream_options: {"include_usage": true}` in your request. */
  usage: ChatCompletionUsage.optional(),
});

export type ChatCompletionChunk = z.infer<typeof ChatCompletionChunk>;
