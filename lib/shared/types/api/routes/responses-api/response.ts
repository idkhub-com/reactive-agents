/**
 * OpenAI API Responses - Structured Outputs Schema
 *
 * Compatible with OpenAI API version 2024-10-21 (latest GA)
 * Supports structured outputs for models including:
 * - gpt-4.5-preview (2025-02-27)
 * - o3-mini (2025-01-31), o3 (2025-04-16)
 * - o4-mini (2025-04-16)
 * - gpt-4.1 series (2025-04-14)
 * - gpt-4o, gpt-4o-mini, o1 models
 *
 * Last updated: January 2025
 */

import { ChatCompletionMessageRole } from '@shared/types/api/routes/shared/messages';
import { z } from 'zod';

/**
 * File citation annotation in structured output content
 */
export const FileCitationAnnotation = z.object({
  type: z.literal('file_citation'),
  text: z.string(),
  file_citation: z.object({
    file_id: z.string(),
    quote: z.string().optional(),
  }),
  start_index: z.number(),
  end_index: z.number(),
});

/**
 * URL citation annotation in structured output content
 */
export const URLCitationAnnotation = z.object({
  type: z.literal('url_citation'),
  text: z.string(),
  url_citation: z.object({
    url: z.string(),
    title: z.string().optional(),
  }),
  start_index: z.number(),
  end_index: z.number(),
});

/**
 * File path annotation in structured output content
 */
export const FilePathAnnotation = z.object({
  type: z.literal('file_path'),
  text: z.string(),
  file_path: z.object({
    file_id: z.string(),
  }),
  start_index: z.number(),
  end_index: z.number(),
});

/**
 * Union type for all possible annotation types in structured outputs
 */
export const ResponsesAPIOutputAnnotation = z.union([
  FileCitationAnnotation,
  URLCitationAnnotation,
  FilePathAnnotation,
]);

export type ResponsesAPIOutputAnnotation = z.infer<
  typeof ResponsesAPIOutputAnnotation
>;

/**
 * Content item in a structured output response from the model.
 * Represents a text output with annotations.
 */
export const ResponsesAPIOutputContent = z.object({
  /**
   * Array of annotations for the text output (file citations, URL citations, file paths, etc.)
   */
  annotations: z.array(ResponsesAPIOutputAnnotation),
  /**
   * The text content generated by the model
   */
  text: z.string(),
  /**
   * The type of content, typically "text" for structured outputs
   */
  type: z.string(),
});

export type ResponsesAPIOutputContent = z.infer<
  typeof ResponsesAPIOutputContent
>;

/**
 * An output item from the model containing content and metadata.
 */
export const ResponsesAPIOutput = z.object({
  /**
   * Unique identifier for this output item
   */
  id: z.string(),
  /**
   * The type of output item - "message" for messages output
   */
  type: z.literal('message'),
  /**
   * The role of the message sender (typically "assistant" for model responses)
   */
  role: z.enum(ChatCompletionMessageRole),
  /**
   * Array of content items generated by the model
   */
  content: z.array(ResponsesAPIOutputContent),
  /**
   * Status of the output generation (e.g., "in_progress", "completed", "incomplete")
   */
  status: z.string().optional(),
});

export type ResponsesAPIOutput = z.infer<typeof ResponsesAPIOutput>;

/**
 * A tool call to run a function. See the
 * [function calling guide](https://platform.openai.com/docs/guides/function-calling)
 * for more information.
 */
export const ResponsesAPIFunctionCall = z.object({
  /**
   * A JSON string of the arguments to pass to the function.
   */
  arguments: z.string(),

  /**
   * The unique ID of the function tool call generated by the model.
   */
  call_id: z.string(),

  /**
   * The name of the function to run.
   */
  name: z.string(),

  /**
   * The type of the function tool call.
   */
  type: z.literal('function'),

  /**
   * The unique ID of the function tool call.
   */
  id: z.string().optional(),

  /**
   * The status of the item. One of `in_progress`, `completed`, or `incomplete`.
   * Populated when items are returned via API.
   */
  status: z
    .union([
      z.literal('in_progress'),
      z.literal('completed'),
      z.literal('incomplete'),
    ])
    .optional(),
});

export type ResponsesAPIFunctionCall = z.infer<typeof ResponsesAPIFunctionCall>;

/**
 * An error object returned when the model fails to generate a Response.
 */
export const ResponsesResponseBodyError = z.object({
  /**
   * The error code for the response.
   */
  code: z.string(),

  /**
   * A human-readable description of the error.
   */
  message: z.string(),
});

export type ResponsesResponseBodyError = z.infer<
  typeof ResponsesResponseBodyError
>;

enum ResponseFormatTextConfigTypeName {
  JSON_SCHEMA = 'json_schema',
  JSON_OBJECT = 'json_object',
  TEXT = 'text',
}

/**
 * Configuration for structured outputs using JSON Schema.
 * This enables Structured Outputs which ensures the model will match your supplied JSON schema.
 */
export const ResponseFormatTextConfig = z.object({
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: z.string().optional(),
  /**
   * The JSON schema for the response format, described as a JSON Schema object.
   */
  schema: z.record(z.string(), z.unknown()).optional().nullable(),
  /**
   * Whether to enable strict schema adherence when generating the output.
   * If set to true, the model will always follow the exact schema defined in the schema field.
   */
  strict: z.boolean().optional().nullable(),
  /**
   * The type of response format. Should be "json_schema" for structured outputs.
   */
  type: z.enum(ResponseFormatTextConfigTypeName),
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description: z.string().nullable().optional(),
});

export type ResponseFormatTextConfig = z.infer<typeof ResponseFormatTextConfig>;

/**
 * Configuration options for a text response from the model.
 * Can be plain text or structured JSON data using JSON Schema.
 */
export const ResponseTextConfig = z.object({
  /**
   * An object specifying the format that the model must output.
   *
   * Configuring with type "json_schema" enables Structured Outputs, which
   * ensures the model will match your supplied JSON schema.
   *
   * The default format is "text" with no additional options.
   */
  format: ResponseFormatTextConfig.optional(),
});

export type ResponseTextConfig = z.infer<typeof ResponseTextConfig>;

/**
 * Common structured output formats based on OpenAI's documentation examples
 */

/**
 * Math reasoning step structure for educational applications
 */
export const MathReasoningStep = z.object({
  /**
   * Explanation of what is being done in this step
   */
  explanation: z.string(),
  /**
   * The mathematical output or equation for this step
   */
  output: z.string(),
});

export type MathReasoningStep = z.infer<typeof MathReasoningStep>;

/**
 * Complete math reasoning structure with steps and final answer
 */
export const MathReasoning = z.object({
  /**
   * Array of reasoning steps to solve the problem
   */
  steps: z.array(MathReasoningStep),
  /**
   * The final answer to the mathematical problem
   */
  final_answer: z.string(),
});

export type MathReasoning = z.infer<typeof MathReasoning>;

/**
 * Article summary concept for content extraction
 */
export const ArticleConcept = z.object({
  /**
   * Title of the concept
   */
  title: z.string(),
  /**
   * Description explaining the concept
   */
  description: z.string(),
});

export type ArticleConcept = z.infer<typeof ArticleConcept>;

/**
 * Structured article summary for content processing
 */
export const ArticleSummary = z.object({
  /**
   * Year the invention/topic was created
   */
  invented_year: z.number(),
  /**
   * One sentence summary of the topic
   */
  summary: z.string(),
  /**
   * Array of inventor names or key people
   */
  inventors: z.array(z.string()),
  /**
   * Detailed description of the invention/topic
   */
  description: z.string(),
  /**
   * Key concepts related to the topic
   */
  concepts: z.array(ArticleConcept),
});

export type ArticleSummary = z.infer<typeof ArticleSummary>;

/**
 * Represents a refusal by the model to generate content that violates usage policies.
 * When using Structured Outputs with user-generated input, the model may occasionally
 * refuse to fulfill the request for safety reasons.
 */
export const ResponseRefusal = z.object({
  /**
   * The refusal message explaining why the model declined to generate content
   */
  refusal: z.string(),
});

export type ResponseRefusal = z.infer<typeof ResponseRefusal>;

/**
 * Enhanced structured output that can include either content or a refusal
 */
export const ResponsesAPIOutputWithRefusal = z.object({
  /**
   * Unique identifier for this output item
   */
  id: z.string(),
  /**
   * The type of output item (e.g., "message")
   */
  type: z.literal('message'),
  /**
   * The role of the message sender (typically "assistant" for model responses)
   */
  role: z.enum(ChatCompletionMessageRole),
  /**
   * Array of content items generated by the model (present when request is fulfilled)
   */
  content: z.array(ResponsesAPIOutputContent).optional(),
  /**
   * Status of the output generation (e.g., "in_progress", "completed", "incomplete")
   */
  status: z.string().optional(),
  /**
   * Refusal message when the model declines to generate content for safety reasons
   */
  refusal: z.string(),
});

export type ResponsesAPIOutputWithRefusal = z.infer<
  typeof ResponsesAPIOutputWithRefusal
>;
/**
 * An invocation of a tool on an MCP server.
 */
export const McpCall = z.object({
  /**
   * The unique ID of the tool call.
   */
  id: z.string(),

  /**
   * A JSON string of the arguments passed to the tool.
   */
  arguments: z.string(),

  /**
   * The name of the tool that was run.
   */
  name: z.string(),

  /**
   * The label of the MCP server running the tool.
   */
  server_label: z.string(),

  /**
   * The type of the item. Always `mcp_call`.
   */
  type: z.literal('mcp_call'),

  /**
   * The error from the tool call, if any.
   */
  error: z.string().nullable().optional(),

  /**
   * The output from the tool call.
   */
  output: z.string().nullable().optional(),
});

export type McpCall = z.infer<typeof McpCall>;

/**
 * A request for human approval of a tool invocation.
 */
export const McpApprovalRequest = z.object({
  /**
   * The unique ID of the approval request.
   */
  id: z.string(),

  /**
   * A JSON string of arguments for the tool.
   */
  arguments: z.string(),

  /**
   * The name of the tool to run.
   */
  name: z.string(),

  /**
   * The label of the MCP server making the request.
   */
  server_label: z.string(),

  /**
   * The type of the item. Always `mcp_approval_request`.
   */
  type: z.literal('mcp_approval_request'),
});

export type McpApprovalRequest = z.infer<typeof McpApprovalRequest>;

/**
 * A list of tools available on an MCP server.
 */
export const McpListTools = z.object({
  /**
   * The unique ID of the list.
   */
  id: z.string(),

  /**
   * The label of the MCP server.
   */
  server_label: z.string(),

  /**
   * The tools available on the server.
   */
  tools: z.array(z.unknown()),

  /**
   * The type of the item. Always `mcp_list_tools`.
   */
  type: z.literal('mcp_list_tools'),

  /**
   * Error message if the server could not list tools.
   */
  error: z.string().nullable().optional(),
});

export type McpListTools = z.infer<typeof McpListTools>;

/**
 * Structured reasoning output from o1 models that includes reasoning traces
 */
export const ResponsesAPIReasoningOutput = z.object({
  /**
   * Unique identifier for this reasoning output
   */
  id: z.string(),
  /**
   * The type of output item - "reasoning" for reasoning traces
   */
  type: z.literal('reasoning'),
  /**
   * Summary of the reasoning process
   */
  summary: z.array(z.string()),
  /**
   * Detailed reasoning trace (optional)
   */
  trace: z.string().optional(),
});

export type ResponsesAPIReasoningOutput = z.infer<
  typeof ResponsesAPIReasoningOutput
>;

export const ResponsesResponseBody = z.object({
  id: z.string(),
  created_at: z.number(),
  error: z
    .object({
      code: z.string(),
      message: z.string(),
    })
    .nullable(),
  incomplete_details: z
    .object({
      reason: z
        .union([z.literal('max_output_tokens'), z.literal('content_filter')])
        .optional(),
    })
    .nullable(),
  instructions: z.string().nullable(),
  metadata: z
    .record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
    .nullable(),
  model: z.string(),
  object: z.literal('response'),
  /**
   * An array of content items generated by the model.
   *
   * - The length and order of items in the output array is dependent on the model's response.
   * - Rather than accessing the first item in the output array and assuming it's an assistant
   *   message with the content generated by the model, you might consider using the output_text
   *   property where supported in SDKs.
   * - Items may include refusal messages when the model declines unsafe requests.
   * - Items may include reasoning traces for o1 models.
   */
  output: z.array(
    z.union([
      ResponsesAPIOutput,
      ResponsesAPIFunctionCall,
      ResponsesAPIReasoningOutput,
      ResponsesAPIOutputWithRefusal,
      McpCall,
      McpListTools,
      McpApprovalRequest,
    ]),
  ),
  output_text: z.string().nullable().optional(),
  parallel_tool_calls: z.boolean().nullable(),
  previous_response_id: z.string().nullable(),
  reasoning: z
    .object({
      effort: z
        .union([z.literal('low'), z.literal('medium'), z.literal('high')])
        .nullable()
        .optional(),
    })
    .nullable(),
  reasoning_effort: z
    .union([z.literal('low'), z.literal('medium'), z.literal('high')])
    .nullable()
    .optional(),
  status: z
    .union([
      z.literal('completed'),
      z.literal('failed'),
      z.literal('in_progress'),
      z.literal('incomplete'),
    ])
    .nullable()
    .optional(),
  store: z.boolean().optional(),
  system_fingerprint: z.string().optional(),
  temperature: z.number().nullable(),
  /**
   * Configuration options for a text response from the model. Can be plain text or
   * structured JSON data. Learn more:
   *
   * - [Text inputs and outputs](https://platform.openai.com/docs/guides/text)
   * - [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)
   */
  text: ResponseTextConfig.nullable().optional(),
  tool_choice: z
    .union([
      z.literal('none'),
      z.literal('auto'),
      z.literal('required'),
      z.object({
        type: z.string(),
        name: z.string().nullable().optional(),
      }),
    ])
    .nullable()
    .optional(),
  tools: z.array(
    z.object({
      type: z.string(),
      function: z
        .object({
          name: z.string(),
          description: z.string().nullable().optional(),
          parameters: z.record(z.string(), z.unknown()).nullable().optional(),
          strict: z.boolean().nullable().optional(),
        })
        .nullable()
        .optional(),
      // File search tool fields
      vector_store_ids: z.array(z.string()).nullable().optional(),
      filters: z.unknown().nullable().optional(),
      max_num_results: z.number().nullable().optional(),
      ranking_options: z
        .object({
          ranker: z
            .union([z.literal('auto'), z.literal('default-2024-11-15')])
            .nullable()
            .optional(),
          score_threshold: z.number().nullable().optional(),
        })
        .nullable()
        .optional(),
      // Computer tool fields
      display_height: z.number().optional(),
      display_width: z.number().optional(),
      environment: z
        .union([
          z.literal('mac'),
          z.literal('windows'),
          z.literal('ubuntu'),
          z.literal('browser'),
        ])
        .nullable()
        .optional(),
      // Web search tool fields
      search_context_size: z
        .union([z.literal('low'), z.literal('medium'), z.literal('high')])
        .nullable()
        .optional(),
      user_location: z
        .object({
          type: z.literal('approximate'),
          city: z.string().optional(),
          country: z.string().optional(),
          region: z.string().optional(),
          timezone: z.string().optional(),
        })
        .nullable()
        .optional(),
      // Image generation tool fields
      partial_images: z.number().optional(),
      // MCP tool fields
      server_label: z.string().nullable().optional(),
      server_url: z.string().nullable().optional(),
      require_approval: z
        .union([z.literal('always'), z.literal('never')])
        .nullable()
        .optional(),
      headers: z.record(z.string(), z.string()).nullable().optional(),
    }),
  ),
  top_p: z.number().nullable().optional(),
  max_output_tokens: z.number().nullable().optional(),
  truncation: z
    .union([z.literal('auto'), z.literal('disabled')])
    .nullable()
    .optional(),
  usage: z
    .object({
      input_tokens: z.number(),
      input_tokens_details: z
        .object({
          cached_tokens: z.number(),
        })
        .nullable()
        .optional(),
      output_tokens: z.number(),
      output_tokens_details: z.object({
        reasoning_tokens: z.number(),
      }),
      total_tokens: z.number(),
    })
    .nullable(),
  user: z.string().nullable(),
  // Internal fields used by the system (not part of official OpenAI API)
  provider: z.string().nullable().optional(),
  service_tier: z
    .union([z.literal('scale'), z.literal('default')])
    .nullable()
    .optional(),
});

export type ResponsesResponseBody = z.infer<typeof ResponsesResponseBody>;

export const ListResponsesResponseBody = z.object({
  object: z.literal('list'),
  data: z.array(ResponsesResponseBody),
  first_id: z.string().nullable(),
  last_id: z.string().nullable(),
  has_more: z.boolean(),
});

export type ListResponsesResponseBody = z.infer<
  typeof ListResponsesResponseBody
>;

export const DeleteResponseResponseBody = z.object({
  id: z.string(),
  object: z.literal('response.deleted'),
  deleted: z.literal(true),
});

export type DeleteResponseResponseBody = z.infer<
  typeof DeleteResponseResponseBody
>;

export const ResponseInputItem = z.object({
  id: z.string(),
  object: z.literal('response.input_item'),
  created_at: z.number(),
  content: z.union([z.string(), z.array(z.unknown())]),
  type: z.enum(['text', 'message']),
});

export type ResponseInputItem = z.infer<typeof ResponseInputItem>;

export const ListResponseInputItemsResponseBody = z.object({
  object: z.literal('list'),
  data: z.array(ResponseInputItem),
  first_id: z.string().nullable(),
  last_id: z.string().nullable(),
  has_more: z.boolean(),
});

export type ListResponseInputItemsResponseBody = z.infer<
  typeof ListResponseInputItemsResponseBody
>;

export const GetResponseResponseBody = ResponseInputItem;

export type GetResponseResponseBody = z.infer<typeof GetResponseResponseBody>;

/**
 * Emitted when the model response is complete.
 */
export const ResponseCompletedEvent = z.object({
  /**
   * Properties of the completed response.
   */
  response: ResponsesResponseBody,

  /**
   * The type of the event. Always `response.completed`.
   */
  type: z.literal('response.completed'),
});

export type ResponseCompletedEvent = z.infer<typeof ResponseCompletedEvent>;
